import logging
import re
import requests
from slugify import slugify

from http import HTTPStatus

LOGGER = logging.getLogger(__name__)


def enumizy_name(name: str) -> str:
    replace_pairs = [
        (r"d'", "d "),
        (r"'s", "s"),
        (r", nes", ""),
        # (r"\(.*\)", ""),
        (r"\(Plurinational State of\)", "")
    ]
    for p in replace_pairs:
        name = re.sub(p[0], p[1], name)
    slug = slugify(name).upper().replace("-", "_")
    # We could've made this RegEx part of replace_pairs, but unsure how it deals with non-ASCII starting characters.
    # Enums names must start with a letter.
    return re.sub(r"^[^a-zA-Z]*", "", slug)


def generate_enums(urls, output_filepath, parse_response, include_header=True, name_transform=None):
    """Generate Enum `model_name` from Entities merged from `urls` written into `output_file`.

    :param urls: merge all key/values from these urls
    :param output_filepath: where to write (BEWARE: Default is to override existing files)
    :param parse_response: function from requests.Response to a dict(ModelName -> tuple(emum name, enum value)).
    :param include_header: useful when generating multiple Enum models into the same file (good for brief ones).
    :param name_transform: additional transformation on name = name_transform(name, value)
    :return: Exception in case of error.
    """
    LOGGER.info(f"Generating enums from {len(urls)} urls to {output_filepath}")

    model_to_name_to_values = {}
    longest_name = ""
    for url in urls:
        LOGGER.info(f"Fetching data from {url}")
        response = requests.get(url)
        if response.status_code != HTTPStatus.OK:
            raise Exception(f"Non 200 status code {response.status_code} for {url}")
        LOGGER.info("... Fetching done.")

        data = parse_response(response)
        # Merge it with existing
        for model_name, name_values in data.items():
            if model_name not in model_to_name_to_values:
                model_to_name_to_values[model_name] = {}
            for raw_name, value in name_values.items():
                # Transform
                name = enumizy_name(raw_name)
                if len(name) > len(longest_name):
                    longest_name = name
                if name_transform:
                    name = name_transform(name, value)

                # Store
                orig_value = model_to_name_to_values[model_name].get(name, None)
                if orig_value != value:
                    Exception(f"For {model_name}, tried to override {name}:{orig_value} with a different value {value}")
                model_to_name_to_values[model_name][name] = value

    with open(output_filepath, "w") as output_file:
        if include_header:
            output_file.write(f"# Generated by `python3 {__name__}`, DO NOT CHANGE, change the generator script\n")
            output_file.write(f"from utils.utils import MMEnum\n")

        for model_name, name_values in model_to_name_to_values.items():
            LOGGER.info(f"Generating {model_name} with {len(name_values)} values")

            output_file.write(f"\n\nclass {model_name}(MMEnum):\n")
            # TODO: Maybe append a docstring from the generator metadata.
            for name, value in name_values.items():
                output_file.write(f"    {name} = \"{value}\"\n")
            output_file.write("\n")

            LOGGER.info("... Generating done.")

    # Print some fun-facts lol
    LOGGER.info(f"Longest name was: {longest_name}")
